<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Verifier Demo</title>
    <link rel="stylesheet" th:href="@{/css/verifier.css}" />

  </head>
  <body>
    <div class="card">
      <div class="actions" style="justify-content: space-between;">
        <div>
          <h1 style="margin-bottom: 0.25rem;">Verifier Demo</h1>
          <p style="margin:0;">Start an OID4VP same-device flow against the wallet running in this app.</p>
        </div>
	        <div style="display:flex;gap:0.5rem;flex-wrap:wrap;align-items:center;">
	          <button type="button" class="btn secondary" id="open-dcql-request">Open DCQL request</button>
	          <span th:if="${sandboxAvailable}" id="sandbox-buttons" style="display:inline-flex;gap:0.25rem;" th:attr="data-sandbox-url=@{/verifier/sandbox-defaults},data-mock-url=@{/verifier/mock-defaults}">
	            <button type="button" class="btn" id="sandbox-sd-jwt">Sandbox SD-JWT</button>
	            <button type="button" class="btn" id="sandbox-mdoc">Sandbox mDoc</button>
	            <button type="button" class="btn" id="sandbox-both">Sandbox Both</button>
	            <button type="button" class="btn secondary" id="sandbox-mock" style="display:none;">Use Mock Defaults</button>
	          </span>
	          <a class="btn secondary" th:href="@{/verifier/conformance}" aria-label="Open OIDF conformance UI">Conformance Suite</a>
	          <a class="btn secondary" th:href="@{/}" aria-label="Go to wallet issuance UI">Go to Wallet</a>
	        </div>
	      </div>

	      <form class="stack" method="post" th:action="@{/verifier/start}">

        <div class="grid" style="grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));">
          <div>
            <label for="walletAuthEndpoint">Wallet Authorization Endpoint</label>
            <small style="color:#475569;">Override to point at a real wallet.</small>
            <input id="walletAuthEndpoint" name="walletAuthEndpoint" type="url" style="width:100%;padding:0.65rem;border-radius:10px;border:1px solid #1f2937;"
                   th:value="${defaultWalletAuthEndpoint}" />
          </div>
          <div>
            <label for="walletAudience">Request Object aud (optional)</label>
            <small style="color:#475569;">Defaults to <code>https://self-issued.me/v2</code> (OID4VP 1.0 static discovery).</small>
            <input id="walletAudience" name="walletAudience" type="text" style="width:100%;padding:0.65rem;border-radius:10px;border:1px solid #1f2937;"
                   th:value="${defaultWalletAudience}" />
          </div>
          <div>
            <label for="walletClientId">Wallet Client ID</label>
            <input id="walletClientId" name="walletClientId" type="text" style="width:100%;padding:0.65rem;border-radius:10px;border:1px solid #1f2937;"
                   th:value="${defaultWalletClientId}" />
          </div>
          <div>
            <label for="authType">Client authentication</label>
            <select id="authType" name="authType" style="width:100%;padding:0.65rem;border-radius:10px;border:1px solid #1f2937;">
              <option value="plain" th:selected="${defaultAuthType == 'plain'}">Plain client_id (demo default)</option>
              <option value="x509_hash" th:selected="${defaultAuthType == 'x509_hash'}">x509_hash (hash of certificate)</option>
              <option value="x509_san_dns" th:selected="${defaultAuthType == 'x509_san_dns'}">x509_san_dns (DNS SAN in certificate)</option>
              <option value="verifier_attestation" th:selected="${defaultAuthType == 'verifier_attestation'}">verifier_attestation (request-signed with PoP key)</option>
            </select>
            <small style="color:#475569;">Choose how the verifier authenticates; for attestation or x509 you must provide the required material.</small>
          </div>
          <div id="request-object-mode" style="display:none;">
            <label for="requestObjectMode">Request object delivery</label>
            <select id="requestObjectMode" name="requestObjectMode" style="width:100%;padding:0.65rem;border-radius:10px;border:1px solid #1f2937;">
              <option value="request" th:selected="${defaultRequestObjectMode == 'request'}">Embed in request parameter</option>
              <option value="request_uri" th:selected="${defaultRequestObjectMode == 'request_uri'}">Pass by reference (request_uri)</option>
            </select>
            <label for="requestUriMethod" style="margin-top:0.35rem;">Request URI method</label>
            <select id="requestUriMethod" name="requestUriMethod" style="width:100%;padding:0.65rem;border-radius:10px;border:1px solid #1f2937;">
              <option value="post" th:selected="${defaultRequestUriMethod == 'post'}">POST (preferred)</option>
              <option value="get" th:selected="${defaultRequestUriMethod == 'get'}">GET</option>
            </select>
            <small style="color:#475569;">Available for x509_hash. verifier_attestation is always sent via <code>request_uri</code> hosted by this verifier.</small>
          </div>
          <div>
            <label for="responseType">Response Type</label>
            <select id="responseType" name="responseType" style="width:100%;padding:0.65rem;border-radius:10px;border:1px solid #1f2937;">
              <option value="vp_token">vp_token</option>
              <option value="vp_token id_token">vp_token + id_token</option>
            </select>
          </div>
          <div>
            <label for="responseMode">Response Mode</label>
            <select id="responseMode" name="responseMode" style="width:100%;padding:0.65rem;border-radius:10px;border:1px solid #1f2937;">
              <option th:selected="${defaultResponseMode == 'direct_post'}" value="direct_post">direct_post</option>
              <option th:selected="${defaultResponseMode == 'direct_post.jwt'}" value="direct_post.jwt">direct_post.jwt (encrypted)</option>
            </select>
            <small style="color:#475569;">Use direct_post.jwt for conformance encrypted responses.</small>
          </div>
          <div id="auth-x509">
            <div id="x509-editable">
              <label for="walletClientCert">Client certificate + private key (PEM)</label>
              <textarea id="walletClientCert" name="walletClientCert" placeholder="-----BEGIN CERTIFICATE-----&#10;-----BEGIN PRIVATE KEY-----" style="width:100%;min-height:120px;padding:0.75rem;border-radius:10px;border:1px solid #1f2937;"></textarea>
              <div class="descriptor-actions" style="margin-top:0.35rem;align-items:center;justify-content:space-between;flex-wrap:wrap;">
                <button type="button" class="btn secondary mini" id="derive-x509-hash">Use x509_hash client_id</button>
                <small style="color:#475569;">Include private key for PoP. Used for x509-bound <code>client_id</code>; the helper fills <code>x509_hash:&lt;sha256(cert)&gt;</code> and the request is signed with this key. If left empty, the verifier will use its own certificate (<span th:text="${defaultX509ClientId}">x509_hash</span>).</small>
              </div>
            </div>
            <div id="x509-sandbox" style="display:none;">
              <label>Sandbox certificate chain (read-only)</label>
              <textarea id="sandboxCertDisplay" readonly style="width:100%;min-height:100px;padding:0.75rem;border-radius:10px;border:1px solid #1f2937;background:#f8fafc;font-family:monospace;font-size:0.8rem;"></textarea>
              <div style="margin-top:0.35rem;">
                <small style="color:#475569;">Private key: <strong>stored server-side only</strong> (not sent to browser). The sandbox key file is used automatically for signing.</small>
              </div>
            </div>
          </div>
          <div id="auth-attestation" style="display:none;">
            <label for="attestationIssuer">Verifier attestation issuer</label>
            <input id="attestationIssuer" name="attestationIssuer" type="text" style="width:100%;padding:0.65rem;border-radius:10px;border:1px solid #1f2937;" value="demo-attestation-issuer" />
            <label for="attestationCert" style="margin-top:0.35rem;">Attestation signing certificate (PEM, optional)</label>
            <textarea id="attestationCert" name="attestationCert" placeholder="-----BEGIN CERTIFICATE-----&#10;-----BEGIN PRIVATE KEY-----" style="width:100%;min-height:140px;padding:0.75rem;border-radius:10px;border:1px solid #1f2937;"></textarea>
            <small style="color:#475569;">If provided (with private key), the verifier attestation and request object are signed with this key; otherwise the verifier key is used. Attestation JWTs are auto-generated; pasting one is not allowed.</small>
          </div>
          <div>
            <label for="trustList">Trust List</label>
            <select id="trustList" name="trustList" style="width:100%;padding:0.65rem;border-radius:10px;border:1px solid #1f2937;">
              <option th:each="opt : ${trustLists}"
                      th:value="${opt.id()}"
                      th:text="${opt.label()}"
                      th:selected="${opt.id() == defaultTrustList}">trust list</option>
            </select>
            <small style="color:#475569;">Choose an invalid list to test failure paths.</small>
          </div>
          <div id="verifier-info-section">
            <label for="verifierInfo">Verifier Info (JSON)</label>
            <textarea id="verifierInfo" name="verifierInfo" placeholder='[{"format": "registration_cert", "data": "<registration certificate JWT>"}]' style="width:100%;min-height:100px;padding:0.75rem;border-radius:10px;border:1px solid #1f2937;"></textarea>
            <small style="color:#475569;">Optional: Array of verifier attestations (e.g., EUDI Wallet registration certificates). <a href="https://bmi.usercontent.opencode.de/eudi-wallet/eidas-2.0-architekturkonzept/content/ecosystem-architecture/trust/wallet-relying-party-authentication/" target="_blank" rel="noreferrer">See spec</a></small>
          </div>
        </div>

        <div class="debug" id="binding-panel" style="margin-top:1rem;"
             th:attr="data-default-x509-id=${defaultX509ClientId},data-default-x509-san-id=${defaultX509SanClientId},data-default-x509-cert=${defaultX509Cert},data-default-x509-source=${defaultX509Source}">
          <div class="actions" style="justify-content: space-between;align-items:center;flex-wrap:wrap;">
            <div>
              <h3 style="margin:0;">Client Binding Preview</h3>
              <small style="color:#475569;">Live view of the client_id and certificate that will be sent to the wallet.</small>
            </div>
            <span class="chip" id="binding-auth-type">plain</span>
          </div>
          <div style="margin-top:0.5rem;">
            <div style="margin-bottom:0.35rem;">Client ID: <code id="binding-client-id" th:text="${defaultWalletClientId}"></code></div>
            <div id="binding-x509-details" style="display:none;">
              <div>Certificate hash: <code id="binding-x509-hash"></code></div>
              <div style="margin-top:0.25rem;">Source: <span id="binding-x509-source"></span></div>
              <textarea id="binding-x509-cert" readonly style="width:100%;min-height:120px;margin-top:0.5rem;"></textarea>
              <div class="descriptor-actions" style="margin-top:0.35rem;align-items:center;justify-content:space-between;flex-wrap:wrap;">
                <button type="button" class="btn secondary mini" id="copy-x509-cert">Copy certificate</button>
                <small style="color:#475569;">Certificate (no private key) will be sent in the request object (x5c).</small>
              </div>
            </div>
          </div>
        </div>

        <div>
            <div class="builder">
              <div class="builder-header">
                <div>
                  <label for="dcqlQueryRaw">DCQL Query</label>
                  <small style="color:#475569;">Build a dcql_query or switch to raw JSON editing.</small>
                </div>
                <div class="descriptor-actions">
                  <button type="button" class="btn" id="dcql-mode-builder">Builder</button>
                  <button type="button" class="btn secondary" id="dcql-mode-raw">Raw edit</button>
                </div>
              </div>

            <div class="descriptor-actions" style="align-items:center;justify-content:space-between;flex-wrap:wrap;margin-top:0.65rem;">
              <div style="display:flex;align-items:center;gap:0.5rem;flex-wrap:wrap;">
                <span style="font-weight:700;">Response encryption</span>
                <button type="button" class="btn secondary mini" id="encryption-toggle">Enable</button>
                <span id="encryption-state" class="chip" style="background:#e2e8f0;color:#0f172a;">Off</span>
              </div>
              <small style="color:#475569;">Builder toggles encryption using the verifier JWKS. Edit JWKS only in Raw mode.</small>
            </div>

            <div id="dcql-builder-panel">
              <datalist id="dcql-format-options">
                <option value="dc+sd-jwt"></option>
                <option value="mso_mdoc"></option>
                <option value="all"></option>
              </datalist>
              <div id="dcql-descriptors"></div>
              <div class="descriptor-actions" style="margin-top:0.75rem;">
                <button type="button" class="btn secondary mini" data-action="add-descriptor">+ Add credential request</button>
              </div>
              <div id="credential-sets-panel" style="display:none;margin-top:0.75rem;">
                <div class="descriptor-card" style="background:#f0f9ff;">
                  <div style="display:flex;justify-content:space-between;align-items:center;">
                    <div>
                      <h4 style="margin:0;">credential_sets</h4>
                      <small style="color:#475569;">Top-level credential set options (e.g. accept SD-JWT <em>or</em> mDoc)</small>
                    </div>
                    <button type="button" class="btn secondary mini" id="remove-credential-sets">Remove</button>
                  </div>
                  <textarea id="credential-sets-json" rows="4" style="font-family:monospace;font-size:0.85rem;margin-top:0.5rem;width:100%;padding:0.5rem;border-radius:8px;border:1px solid #1f2937;"></textarea>
                </div>
              </div>
              <div style="margin-top:0.75rem;">
                <label>Request object preview (read-only)</label>
                <small style="color:#475569;">Preview of the JWT claims sent to the wallet. <code>state</code>, <code>nonce</code>, <code>response_uri</code>, and <code>exp</code> are generated on submit.</small>
                <pre id="dcql-builder-preview" class="dcql-preview">Loading builder...</pre>
              </div>
            </div>

            <div id="dcql-raw-panel" style="display:none;margin-top:0.75rem;">
              <div class="descriptor-actions" style="justify-content: space-between;">
                <div style="color:#475569;">Edit JSON manually. Builder changes will not sync while in this mode.</div>
                <button type="button" class="btn secondary mini soft" id="dcql-reset-from-builder">Load latest builder output</button>
              </div>
              <textarea id="dcqlQueryRaw" style="margin-top:0.5rem;min-height:200px;" th:text="${defaultDcqlQuery}"></textarea>
              <div id="client-metadata-editor" style="margin-top:0.75rem;">
                <label for="clientMetadata">Client Metadata (encryption)</label>
                <textarea id="clientMetadata" name="clientMetadata" placeholder='{"jwks":{...},"response_encryption_alg":"RSA-OAEP-256","response_encryption_enc":"A256GCM"}'
                          th:attr="data-default=${defaultClientMetadata}"
                          th:text="${prefillClientMetadata}"
                          style="width:100%;min-height:140px;padding:0.75rem;border-radius:10px;border:1px solid #1f2937;"></textarea>
                <div class="descriptor-actions" style="margin-top:0.35rem;">
                  <button type="button" class="btn secondary mini" id="load-default-client-metadata">Use verifier JWKS</button>
                  <small style="color:#475569;">Customize the client_metadata JWKS and encryption settings here.</small>
                </div>
              </div>
            </div>
            <input type="hidden" id="dcqlQueryInput" name="dcqlQuery" />
            <input type="hidden" id="useSandboxKey" name="useSandboxKey" value="false" />
          </div>
        </div>
        <div class="actions">
          <button class="btn" type="submit">Request Presentation</button>
          <a class="btn secondary" th:href="@{/verifier/default}" target="_blank">View Defaults</a>
        </div>
      </form>

      <div class="debug">
        <div class="actions" style="justify-content: space-between;">
          <div>
            <h3 style="margin:0;">Verification Debug</h3>
            <small style="color:#475569;">Recent authorization requests and direct_post callbacks.</small>
          </div>
          <button class="btn secondary" id="verification-debug-toggle" type="button">Toggle Debug Pane</button>
        </div>
        <div id="verification-debug-pane" style="display:none;">
          <div th:if="${#lists.isEmpty(verificationDebug)}" style="margin-top:0.5rem;"><em>No verification calls logged yet.</em></div>
          <div class="debug-group" th:each="groupEntry : ${verificationDebugGrouped}">
            <details>
              <summary>
                <span class="summary-title" th:text="'Request ' + ${groupEntry.key}">Group</span>
              </summary>
              <div class="subgroup" th:each="subgroup : ${groupEntry.value}">
                <details>
                  <summary>
                    <span class="summary-title" th:text="${subgroup.key != '' ? subgroup.key : 'General'}">Sub</span>
                    <span class="entry-count" th:text="${#lists.size(subgroup.value)} + ' entries'">0 entries</span>
                  </summary>
                  <div class="log-item" th:each="entry : ${subgroup.value}">
                    <details>
                      <summary>
                        <span th:text="${entry.title()}">Step</span>
                        <div class="log-meta">
                          <span th:text="${entry.timestamp()}"></span>
                          <span class="chip" th:if="${entry.specLink()}">Spec</span>
                        </div>
                      </summary>
                      <div class="debug-entry">
                        <div class="debug-meta">
                          <span th:if="${entry.specLink()}"><a th:href="${entry.specLink()}" target="_blank" rel="noreferrer">Open spec</a></span>
                        </div>
                        <details style="margin-top:0.25rem;">
                          <summary>Request</summary>
                          <div class="http-block">
                            <div><strong th:text="${entry.method()} + ' ' + ${entry.url()}">GET /</strong></div>
                            <div class="http-headers" th:if="${entry.requestHeaders()}">
                              <div class="http-header" th:each="hdr : ${entry.requestHeaders()}" th:text="${hdr.key + ': ' + hdr.value}"></div>
                            </div>
                            <pre class="http-body" th:if="${entry.requestBody()}" th:text="${entry.requestBody()}"></pre>
                          </div>
                        </details>
                        <details style="margin-top:0.25rem;">
                          <summary>Response / Outcome</summary>
                          <div class="http-block">
                            <div>
                              <strong th:text="${entry.responseStatus() != null ? 'HTTP ' + entry.responseStatus() : 'Result'}">HTTP 200</strong>
                            </div>
                            <div class="http-headers" th:if="${entry.responseHeaders()}">
                              <div class="http-header" th:each="hdr : ${entry.responseHeaders()}" th:text="${hdr.key + ': ' + hdr.value}"></div>
                            </div>
                            <pre class="http-body" th:if="${entry.responseBody()}" th:text="${entry.responseBody()}"></pre>
                          </div>
                        </details>
                        <details style="margin-top:0.25rem;" th:if="${entry.decoded()}">
                          <summary>Decoded</summary>
                          <pre class="http-body" style="margin:0;" th:text="${entry.decoded()}"></pre>
                        </details>
                      </div>
                    </details>
                  </div>
                </details>
              </div>
            </details>
          </div>
        </div>
      </div>

    </div>
    <script>
      (() => {
        const form = document.querySelector("form");
        const dcqlHidden = document.getElementById("dcqlQueryInput");
        const dcqlPreview = document.getElementById("dcql-builder-preview");
        const dcqlRawPanel = document.getElementById("dcql-raw-panel");
        const dcqlBuilderPanel = document.getElementById("dcql-builder-panel");
        const dcqlRaw = document.getElementById("dcqlQueryRaw");
        const descriptorsContainer = document.getElementById("dcql-descriptors");
        const modeBuilderBtn = document.getElementById("dcql-mode-builder");
        const modeRawBtn = document.getElementById("dcql-mode-raw");
        const resetRawBtn = document.getElementById("dcql-reset-from-builder");
        const credentialSetsPanel = document.getElementById("credential-sets-panel");
        const credentialSetsJson = document.getElementById("credential-sets-json");
        const removeCredentialSetsBtn = document.getElementById("remove-credential-sets");
        const openBtn = document.getElementById("open-dcql-request");
        const addDescriptorBtn = document.querySelector('[data-action="add-descriptor"]');
        const clientMetadataField = document.getElementById("clientMetadata");
        const clientMetadataButton = document.getElementById("load-default-client-metadata");
        const responseModeSelect = document.getElementById("responseMode");
        const requestUriMethodSelect = document.getElementById("requestUriMethod");
        const encryptionToggle = document.getElementById("encryption-toggle");
        const encryptionState = document.getElementById("encryption-state");
        const clientMetadataEditor = document.getElementById("client-metadata-editor");
        const defaultClientMetadata = clientMetadataField ? clientMetadataField.dataset.default || "" : "";
        const clientIdInput = document.getElementById("walletClientId");
        const clientCertInput = document.getElementById("walletClientCert");
        const x509Editable = document.getElementById("x509-editable");
        const x509Sandbox = document.getElementById("x509-sandbox");
        const sandboxCertDisplay = document.getElementById("sandboxCertDisplay");
        const useSandboxKeyInput = document.getElementById("useSandboxKey");
        const deriveX509Btn = document.getElementById("derive-x509-hash");
        const authTypeSelect = document.getElementById("authType");
        const requestObjectModeContainer = document.getElementById("request-object-mode");
        const requestObjectMode = document.getElementById("requestObjectMode");
        const attestationIssuerInput = document.getElementById("attestationIssuer");
        const attestationCertInput = document.getElementById("attestationCert");
        const authX509 = document.getElementById("auth-x509");
        const authAttestation = document.getElementById("auth-attestation");
        const bindingPanel = document.getElementById("binding-panel");
        const bindingAuthType = document.getElementById("binding-auth-type");
        const bindingClientId = document.getElementById("binding-client-id");
        const bindingX509Details = document.getElementById("binding-x509-details");
        const bindingX509Hash = document.getElementById("binding-x509-hash");
        const bindingX509Source = document.getElementById("binding-x509-source");
        const bindingX509Cert = document.getElementById("binding-x509-cert");
        const copyX509CertBtn = document.getElementById("copy-x509-cert");
        const defaultX509Id = bindingPanel?.dataset.defaultX509Id || "";
        const defaultX509SanId = bindingPanel?.dataset.defaultX509SanId || "";
        const defaultX509Cert = bindingPanel?.dataset.defaultX509Cert || "";
        const defaultX509Source = bindingPanel?.dataset.defaultX509Source || "verifier";

        function firstPemBlock(pem) {
          if (!pem) return null;
          const segments = pem.split("-----BEGIN CERTIFICATE-----");
          for (const segment of segments) {
            const endIndex = segment.indexOf("-----END CERTIFICATE-----");
            if (endIndex !== -1) {
              const body = segment.slice(0, endIndex).replace(/\\s+/g, "");
              if (body) return body;
            }
          }
          return null;
        }

        function pemToDer(pem) {
          const base64 = firstPemBlock(pem);
          if (!base64) return null;
          const binary = atob(base64);
          const bytes = new Uint8Array(binary.length);
          for (let i = 0; i < binary.length; i++) {
            bytes[i] = binary.charCodeAt(i);
          }
          return bytes;
        }

        async function computeX509Hash(pem) {
          if (!window.crypto?.subtle) return null;
          const der = pemToDer(pem);
          if (!der) return null;
          const digest = await crypto.subtle.digest("SHA-256", der);
          const bytes = Array.from(new Uint8Array(digest));
          return btoa(String.fromCharCode(...bytes))
            .replace(/\+/g, "-")
            .replace(/\//g, "_")
            .replace(/=+$/, "");
        }

        async function refreshBindingInsights() {
          const mode = authTypeSelect?.value || "plain";
          if (bindingAuthType) bindingAuthType.textContent = mode;
          if (bindingClientId) bindingClientId.textContent = clientIdInput?.value || "(empty)";
          if (!bindingX509Details) return;
          if (mode !== "x509_hash" && mode !== "x509_san_dns") {
            bindingX509Details.style.display = "none";
            return;
          }
          bindingX509Details.style.display = "block";
          let certText = defaultX509Cert;
          let hash = defaultX509Id && defaultX509Id.includes(":") ? defaultX509Id.split(":")[1] : "";
          let source = defaultX509Source === "verifier_self_signed" ? "Verifier self-signed (auto)" : defaultX509Source;
          if (mode === "x509_san_dns") {
            const sanId = clientIdInput?.value || defaultX509SanId || "";
            if (sandboxCertDisplay?.value.trim()) {
              certText = sandboxCertDisplay.value.trim();
              source = "Sandbox certificate (server-side key)";
            } else if (clientCertInput?.value.trim()) {
              certText = firstPemBlock(clientCertInput.value.trim());
              certText = certText ? "-----BEGIN CERTIFICATE-----\n" + certText + "\n-----END CERTIFICATE-----" : clientCertInput.value.trim();
              source = "Client-supplied PEM";
            }
            if (bindingX509Hash) bindingX509Hash.textContent = sanId || "n/a";
            if (bindingX509Source) bindingX509Source.textContent = source || "";
            if (bindingX509Cert) bindingX509Cert.value = certText || "";
            return;
          }
          if (clientCertInput?.value.trim()) {
            certText = clientCertInput.value.trim();
            source = "Client-supplied PEM";
            hash = await computeX509Hash(certText) || hash;
          }
          if (bindingX509Hash) bindingX509Hash.textContent = hash || "n/a";
          if (bindingX509Source) bindingX509Source.textContent = source || "";
          if (bindingX509Cert) bindingX509Cert.value = certText || "";
        }

        deriveX509Btn?.addEventListener("click", async () => {
          const mode = authTypeSelect?.value || "plain";
          if (mode === "x509_san_dns") {
            if (clientIdInput && defaultX509SanId) {
              clientIdInput.value = defaultX509SanId;
            }
            refreshBindingInsights();
            return;
          }
          if (!clientCertInput?.value.trim()) {
            alert("Paste a client certificate (PEM) first.");
            return;
          }
          const hash = await computeX509Hash(clientCertInput.value);
          if (!hash) {
            alert("Could not derive x509_hash from certificate.");
            return;
          }
          if (clientIdInput) {
            clientIdInput.value = `x509_hash:${hash}`;
          }
          if (authTypeSelect) {
            authTypeSelect.value = "x509_hash";
            refreshAuthSections();
          }
          refreshBindingInsights();
        });

        function refreshAuthSections() {
          const mode = authTypeSelect?.value || "plain";
          if (authX509) authX509.style.display = mode === "x509_hash" || mode === "x509_san_dns" ? "block" : "none";
          if (authAttestation) authAttestation.style.display = mode === "verifier_attestation" ? "block" : "none";
          if (mode === "x509_san_dns" && clientIdInput && !clientIdInput.value && defaultX509SanId) {
            clientIdInput.value = defaultX509SanId;
          }
          const supportsRequestObject = mode === "x509_hash" || mode === "x509_san_dns" || mode === "verifier_attestation";
          const forceRequestUri = mode === "verifier_attestation";
          if (requestObjectModeContainer) requestObjectModeContainer.style.display = supportsRequestObject ? "block" : "none";
          if (requestUriMethodSelect) requestUriMethodSelect.disabled = !supportsRequestObject;
          if (requestObjectMode) {
            requestObjectMode.disabled = !supportsRequestObject || forceRequestUri;
            if (!supportsRequestObject || forceRequestUri) {
              requestObjectMode.value = "request";
            }
            if (forceRequestUri) {
              requestObjectMode.value = "request_uri";
            }
          }
          refreshBindingInsights();
        }
        authTypeSelect?.addEventListener("change", refreshAuthSections);
        refreshAuthSections();
        clientIdInput?.addEventListener("input", () => refreshBindingInsights());
        clientCertInput?.addEventListener("input", () => refreshBindingInsights());
        copyX509CertBtn?.addEventListener("click", () => {
          if (!bindingX509Cert || !bindingX509Cert.value) return;
          navigator.clipboard?.writeText(bindingX509Cert.value).then(() => {
            copyX509CertBtn.textContent = "Copied";
            setTimeout(() => (copyX509CertBtn.textContent = "Copy certificate"), 1200);
          });
        });

        // Update request preview when any relevant form field changes
        for (const id of ["walletClientId", "responseType", "responseMode", "walletAudience", "verifierInfo", "clientMetadata"]) {
          const el = document.getElementById(id);
          el?.addEventListener("input", () => updatePreview(false));
          el?.addEventListener("change", () => updatePreview(false));
        }

        const defaultClaimOptions = [
          "given_name",
          "family_name",
          "birth_family_name",
          "birthdate",
          "place_of_birth",
          "nationalities",
          "address",
          "age_equal_or_over",
          "issuing_country",
          "issuing_authority",
          "source_document_type"
        ];
        const knownFormats = ["dc+sd-jwt", "mso_mdoc", "all"];
        const defaultCredentialFormat = knownFormats[0];
        let builderState = { credentials: [], credentialSets: null };
        let rawInitialized = false;
        let mode = "builder";
        let descriptorCounter = 1;
        let savedClientMetadata = clientMetadataField ? clientMetadataField.value : "";
        let encryptionEnabled = false;

        function defaultClaims() {
          return [
            { name: "given_name", constValue: "" },
            { name: "family_name", constValue: "" }
          ];
        }

        function nextDescriptorId() {
          return `credential-${descriptorCounter++}`;
        }

        function newDescriptor(id, format) {
          return {
            id: id || nextDescriptorId(),
            format: format || defaultCredentialFormat,
            meta: null,
            claims: defaultClaims(),
            claimSets: []
          };
        }

        function addClaim(descriptor, name, constValue) {
          if (!descriptor) return;
          descriptor.claims = descriptor.claims || [];
          descriptor.claims.push({ name: name || "", constValue: constValue || "" });
        }

        function setEncryption(enabled) {
          encryptionEnabled = !!enabled;
          if (clientMetadataField) {
            if (encryptionEnabled) {
              if (!savedClientMetadata.trim()) {
                savedClientMetadata = defaultClientMetadata || savedClientMetadata || "";
              }
              clientMetadataField.value = savedClientMetadata || defaultClientMetadata || "";
            } else {
              savedClientMetadata = clientMetadataField.value;
              clientMetadataField.value = "";
            }
          }
          updateEncryptionUi();
          updatePreview();
        }

        function updateEncryptionUi() {
          if (encryptionToggle) {
            encryptionToggle.textContent = encryptionEnabled ? "Disable encryption" : "Enable encryption";
            encryptionToggle.classList.toggle("secondary", !encryptionEnabled);
          }
          if (encryptionState) {
            encryptionState.textContent = encryptionEnabled ? "On" : "Off";
            encryptionState.style.background = encryptionEnabled ? "#e0f2fe" : "#e2e8f0";
            encryptionState.style.color = encryptionEnabled ? "#0369a1" : "#475569";
          }
        }

        if (clientMetadataButton && clientMetadataField) {
          clientMetadataButton.addEventListener("click", () => {
            if (defaultClientMetadata) {
              clientMetadataField.value = defaultClientMetadata;
              savedClientMetadata = clientMetadataField.value;
              setEncryption(true);
            }
          });
          if (defaultClientMetadata && !clientMetadataField.value.trim()) {
            clientMetadataField.value = defaultClientMetadata;
          }
        }

        if (clientMetadataField) {
          savedClientMetadata = clientMetadataField.value;
          clientMetadataField.addEventListener("input", () => {
            savedClientMetadata = clientMetadataField.value;
          });
        }

        encryptionToggle?.addEventListener("click", () => setEncryption(!encryptionEnabled));

        function defaultBuilderState() {
          const descriptor = newDescriptor("credential-1");
          descriptorCounter = 2;
          return { credentials: [descriptor] };
        }

        function parseInitialDefinition() {
          if (!dcqlRaw || !dcqlRaw.value) {
            builderState = defaultBuilderState();
            return;
          }
          try {
            const parsed = JSON.parse(dcqlRaw.value);
            const creds = Array.isArray(parsed.credentials) ? parsed.credentials : [];
            if (!creds.length) {
              builderState = defaultBuilderState();
              return;
            }
            const descriptors = creds.map((c, idx) => {
              const claims = [];
              const claimNodes = Array.isArray(c.claims) ? c.claims : [];
              claimNodes.forEach((cl) => {
                const path = Array.isArray(cl.path) ? cl.path : [];
                const name = path.length ? path.join(".") : "";
                const val = typeof cl.value !== "undefined" && cl.value !== null ? String(cl.value) : "";
                if (name) {
                  claims.push({ name, constValue: val, originalPath: path.length ? [...path] : null });
                }
              });
              const claimSets = [];
              if (Array.isArray(c.claim_set)) {
                c.claim_set.forEach((set) => {
                  if (typeof set === "string" && set.trim()) {
                    claimSets.push(set.trim());
                  } else if (Array.isArray(set)) {
                    const names = set
                      .map((v) => {
                        if (typeof v === "string") return v;
                        if (v && typeof v === "object" && Array.isArray(v.path)) {
                          return v.path.join(".");
                        }
                        return "";
                      })
                      .filter(Boolean);
                    if (names.length) {
                      claimSets.push(names.join(", "));
                    }
                  } else if (set && typeof set === "object") {
                    const claimsNode = Array.isArray(set.claims) ? set.claims : [];
                    const names = claimsNode
                      .map((v) => {
                        if (typeof v === "string") return v;
                        if (v && typeof v === "object" && Array.isArray(v.path)) {
                          return v.path.join(".");
                        }
                        return "";
                      })
                      .filter(Boolean);
                    if (names.length) {
                      claimSets.push(names.join(", "));
                    }
                  }
                });
              }
              const format =
                typeof c.format === "string" && c.format.trim() ? c.format.trim() : "all";
              const meta = c.meta && typeof c.meta === "object" ? c.meta : null;
              return {
                id: c.id || `credential-${idx + 1}`,
                format,
                meta,
                claims: claims.length ? claims : defaultClaims(),
                claimSets
              };
            });
            builderState = { credentials: descriptors, credentialSets: Array.isArray(parsed.credential_sets) ? parsed.credential_sets : null };
            descriptorCounter = descriptors.length + 1;
          } catch (e) {
            builderState = defaultBuilderState();
          }
        }

        function ensureDescriptors() {
          if (!builderState.credentials.length) {
            builderState.credentials.push(newDescriptor());
          }
        }

        function addDescriptor() {
          builderState.credentials.push(newDescriptor());
          renderBuilder();
          updatePreview();
        }

        function buildDcqlObject() {
          ensureDescriptors();
          const clientMeta = collectClientMetadata();
          const credentials = builderState.credentials.map((descriptor, idx) => {
            const descriptorId = descriptor.id && descriptor.id.trim() ? descriptor.id.trim() : `credential-${idx + 1}`;
            const claims = (descriptor.claims || [])
              .filter((c) => c.name && c.name.trim())
              .map((claim) => {
                let segments;
                if (claim.originalPath) {
                  segments = claim.originalPath;
                } else {
                  const name = claim.name.trim();
                  // Use "/" as path separator (consistent with DCQL spec).
                  // For mso_mdoc, paths must be exactly [namespace, element_identifier].
                  segments = name.includes("/") ? name.split("/").filter(Boolean) : [name];
                }
                const entry = { path: segments };
                if (claim.constValue && claim.constValue.trim()) {
                  entry.value = claim.constValue.trim();
                }
                return entry;
              });
            const formatValue =
              typeof descriptor.format === "string" && descriptor.format.trim()
                ? descriptor.format.trim()
                : defaultCredentialFormat;
            const base = { id: descriptorId, claims };
            if (formatValue && formatValue !== "all") {
              base.format = formatValue;
            }
            if (descriptor.meta && typeof descriptor.meta === "object") {
              base.meta = descriptor.meta;
            }
            const claimSets = Array.isArray(descriptor.claimSets) ? descriptor.claimSets.filter((v) => v && v.trim()) : [];
            if (claimSets.length) {
              base.claim_set = claimSets.map((set) => {
                const names = set.split(",").map((s) => s.trim()).filter(Boolean);
                const claimsForSet = names.map((name) => ({ path: name.includes("/") ? name.split("/").filter(Boolean) : [name] }));
                return { claims: claimsForSet };
              });
            }
            return base;
          });
          const dcql = { credentials };
          if (Array.isArray(builderState.credentialSets) && builderState.credentialSets.length) {
            dcql.credential_sets = builderState.credentialSets;
          }
          return dcql;
        }

        function collectClientMetadata() {
          if (!encryptionEnabled) {
            return null;
          }
          if (!clientMetadataField) {
            return null;
          }
          const raw = (clientMetadataField.value || "").trim();
          if (!raw) {
            return null;
          }
          try {
            return JSON.parse(raw);
          } catch (e) {
            return raw;
          }
        }

        function credentialTypeValue(descriptor) {
          if (!descriptor.meta) return "";
          if (descriptor.format === "mso_mdoc" && descriptor.meta.doctype_value) return descriptor.meta.doctype_value;
          if (Array.isArray(descriptor.meta.vct_values) && descriptor.meta.vct_values.length) return descriptor.meta.vct_values[0];
          return "";
        }

        function renderBuilder() {
          ensureDescriptors();
          descriptorsContainer.innerHTML = builderState.credentials.map((descriptor, di) => {
            const claims = descriptor.claims || [];
            const formatValue =
              descriptor.format && descriptor.format.trim() ? descriptor.format.trim() : defaultCredentialFormat;
            const selectValue = !formatValue || formatValue === "all" ? "all" : formatValue;
            const claimRows = claims.map((claim, ci) => `
              <div class="claim-row">
                <div>
                  <label style="font-weight:600;">Claim path</label>
                  <input type="text" data-di="${di}" data-ci="${ci}" data-field="name" placeholder="e.g. personal_id or address.street_address" value="${claim.name || ""}" />
                </div>
                <div>
                  <label style="font-weight:600;">Value (optional exact match)</label>
                  <input type="text" data-di="${di}" data-ci="${ci}" data-field="const" placeholder="Exact required value" value="${claim.constValue || ""}" />
                </div>
                <div style="display:flex;align-items:flex-end;gap:0.35rem;">
                  <button type="button" class="btn secondary mini" data-action="remove-claim" data-di="${di}" data-ci="${ci}">Remove</button>
                </div>
              </div>
            `).join("");
            return `
              <div class="descriptor-card">
                <div style="display:flex;justify-content:space-between;align-items:center;gap:0.5rem;">
                  <div>
                    <h4 style="margin:0;">Credential request</h4>
                    <small style="color:#475569;">DCQL credential query</small>
                  </div>
                  <button type="button" class="btn secondary mini" data-action="remove-descriptor" data-di="${di}">Remove</button>
                </div>
                <div class="descriptor-actions" style="gap:0.75rem;flex-wrap:wrap;">
                  <div style="flex:1;min-width:200px;">
                    <label style="font-weight:600;">Credential ID</label>
                    <input type="text" data-field="descriptor-id" data-di="${di}" value="${descriptor.id || ""}" style="padding:0.55rem;border-radius:8px;border:1px solid #1f2937;min-width:200px;" />
                  </div>
                  <div style="min-width:220px;">
                    <label style="font-weight:600;">Format</label>
                    <select data-field="format-select" data-di="${di}" style="padding:0.55rem;border-radius:8px;border:1px solid #1f2937;min-width:200px;">
                      ${knownFormats
                        .map((fmt) => `<option value="${fmt}" ${selectValue === fmt ? "selected" : ""}>${fmt}</option>`)
                        .join("")}
                    </select>
                  </div>
                  <div style="flex:1;min-width:200px;${selectValue === "all" ? "display:none;" : ""}" data-role="credential-type-wrapper" data-di="${di}">
                    <label style="font-weight:600;">${selectValue === "mso_mdoc" ? "Document type (doctype)" : "Credential type (vct)"}</label>
                    <input type="text" data-field="credential-type" data-di="${di}" placeholder="${selectValue === "mso_mdoc" ? "eu.europa.ec.eudi.pid.1" : "urn:eudi:pid:de:1"}" value="${credentialTypeValue(descriptor)}" style="padding:0.55rem;border-radius:8px;border:1px solid #1f2937;min-width:200px;" />
                  </div>
                </div>
                <div style="margin-top:0.5rem;display:flex;gap:0.35rem;flex-wrap:wrap;">
                  <button type="button" class="btn secondary mini soft" data-action="add-claim" data-di="${di}">+ Add claim</button>
                  ${defaultClaimOptions.map((opt) => `<button type="button" class="btn secondary mini soft" data-action="add-claim" data-claim="${opt}" data-di="${di}">${opt}</button>`).join("")}
                </div>
                <div style="display:grid;gap:0.5rem;margin-top:0.5rem;">
                  ${claimRows || ""}
                </div>
                <div class="tag-row">
                  <label style="font-weight:600;">claim_set (comma separated)</label>
                  <input type="text" data-field="claim-set" data-di="${di}" placeholder="e.g. name, address" value="${Array.isArray(descriptor.claimSets) ? descriptor.claimSets.join(', ') : ''}" />
                </div>
              </div>
            `;
          }).join("");
          if (credentialSetsPanel) {
            if (Array.isArray(builderState.credentialSets) && builderState.credentialSets.length) {
              credentialSetsPanel.style.display = "block";
              credentialSetsJson.value = JSON.stringify(builderState.credentialSets, null, 2);
            } else {
              credentialSetsPanel.style.display = "none";
              credentialSetsJson.value = "";
            }
          }
        }

        function buildRequestObjectPreview() {
          const dcql = buildDcqlObject();
          const clientId = clientIdInput?.value || "";
          const responseType = document.getElementById("responseType")?.value || "vp_token";
          const responseMode = responseModeSelect?.value || "direct_post";
          const audience = document.getElementById("walletAudience")?.value || "";
          const preview = {
            iss: clientId,
            client_id: clientId,
            response_type: responseType,
            response_mode: responseMode,
            response_uri: "<generated on submit>",
            state: "<generated on submit>",
            nonce: "<generated on submit>"
          };
          if (audience) preview.aud = audience;
          // dcql_query: remove client_metadata (it's a top-level claim, not inside dcql_query)
          const dcqlForPreview = { ...dcql };
          delete dcqlForPreview.client_metadata;
          preview.dcql_query = dcqlForPreview;
          if (encryptionEnabled) {
            const meta = collectClientMetadata();
            if (meta) preview.client_metadata = meta;
          } else if (mode === "raw" && clientMetadataField?.value.trim()) {
            try { preview.client_metadata = JSON.parse(clientMetadataField.value); } catch(e) {}
          }
          const verifierInfoEl = document.getElementById("verifierInfo");
          if (verifierInfoEl?.value.trim()) {
            try { preview.verifier_info = JSON.parse(verifierInfoEl.value); } catch(e) {}
          }
          preview.exp = "<generated on submit>";
          return preview;
        }

        function updatePreview(updateHidden = true) {
          const dcql = buildDcqlObject();
          const preview = buildRequestObjectPreview();
          dcqlPreview.textContent = JSON.stringify(preview, null, 2);
          if (mode === "builder" && updateHidden) {
            dcqlHidden.value = JSON.stringify(dcql);
          }
        }

        function setMode(nextMode) {
          mode = nextMode;
          if (nextMode === "builder") {
            dcqlBuilderPanel.style.display = "block";
            dcqlRawPanel.style.display = "none";
            modeBuilderBtn.classList.remove("secondary");
            modeRawBtn.classList.add("secondary");
            dcqlHidden.value = JSON.stringify(buildDcqlObject());
            if (clientMetadataEditor) {
              clientMetadataEditor.style.display = "none";
            }
            if (clientMetadataField) {
              clientMetadataField.value = encryptionEnabled ? (savedClientMetadata || defaultClientMetadata || "") : "";
            }
          } else {
            dcqlBuilderPanel.style.display = "none";
            dcqlRawPanel.style.display = "block";
            modeBuilderBtn.classList.add("secondary");
            modeRawBtn.classList.remove("secondary");
            if (!rawInitialized) {
              dcqlRaw.value = dcqlPreview.textContent;
              rawInitialized = true;
            }
            dcqlHidden.value = dcqlRaw.value;
            if (clientMetadataEditor) {
              clientMetadataEditor.style.display = "block";
            }
            if (clientMetadataField && encryptionEnabled && !clientMetadataField.value.trim()) {
              clientMetadataField.value = savedClientMetadata || defaultClientMetadata || "";
            }
          }
        }

        function handleDescriptorInput(event) {
          const di = Number(event.target.dataset.di);
          if (Number.isNaN(di)) return;
          const descriptor = builderState.credentials[di];
          if (!descriptor) return;
          if (event.target.dataset.field === "descriptor-id") {
            descriptor.id = event.target.value;
          } else if (event.target.dataset.field === "format-select") {
            descriptor.format = event.target.value;
            // Re-render to update credential-type label/placeholder/visibility
            renderBuilder();
          } else if (event.target.dataset.field === "name" || event.target.dataset.field === "const") {
            const ci = Number(event.target.dataset.ci);
            if (Number.isNaN(ci) || !descriptor.claims[ci]) return;
            if (event.target.dataset.field === "name") {
              descriptor.claims[ci].name = event.target.value;
              descriptor.claims[ci].originalPath = null;
            } else {
              descriptor.claims[ci].constValue = event.target.value;
            }
          } else if (event.target.dataset.field === "credential-type") {
            const val = event.target.value.trim();
            if (!val) {
              descriptor.meta = null;
            } else if (descriptor.format === "mso_mdoc") {
              descriptor.meta = { doctype_value: val };
            } else {
              descriptor.meta = { vct_values: [val] };
            }
          } else if (event.target.dataset.field === "claim-set") {
            descriptor.claimSets = event.target.value.split(",").map((v) => v.trim()).filter(Boolean);
          }
          updatePreview();
        }

        descriptorsContainer.addEventListener("input", handleDescriptorInput);
        descriptorsContainer.addEventListener("change", handleDescriptorInput);

        descriptorsContainer.addEventListener("click", (event) => {
          const action = event.target.dataset.action;
          if (!action) return;
          const di = Number(event.target.dataset.di);
          if (action === "add-descriptor") {
            builderState.credentials.push(newDescriptor());
            renderBuilder();
            updatePreview();
            return;
          }
          if (Number.isNaN(di)) return;
          if (action === "remove-descriptor") {
            builderState.credentials.splice(di, 1);
            renderBuilder();
            updatePreview();
          }
          if (action === "add-claim") {
            const descriptor = builderState.credentials[di];
            if (!descriptor) return;
            addClaim(descriptor, event.target.dataset.claim || "", "");
            renderBuilder();
            updatePreview();
          }
          if (action === "remove-claim") {
            const descriptor = builderState.credentials[di];
            const ci = Number(event.target.dataset.ci);
            if (!descriptor || Number.isNaN(ci)) return;
            descriptor.claims.splice(ci, 1);
            renderBuilder();
            updatePreview();
          }
        });

        addDescriptorBtn?.addEventListener("click", addDescriptor);

        credentialSetsJson?.addEventListener("input", () => {
          try {
            const parsed = JSON.parse(credentialSetsJson.value);
            builderState.credentialSets = Array.isArray(parsed) ? parsed : null;
          } catch (e) { /* keep current value until valid JSON */ }
          updatePreview();
        });

        removeCredentialSetsBtn?.addEventListener("click", () => {
          builderState.credentialSets = null;
          renderBuilder();
          updatePreview();
        });

        dcqlRaw?.addEventListener("input", () => {
          if (mode === "raw") {
            dcqlHidden.value = dcqlRaw.value;
          }
        });

        resetRawBtn?.addEventListener("click", () => {
          dcqlRaw.value = dcqlPreview.textContent;
          rawInitialized = true;
          if (mode === "raw") {
            dcqlHidden.value = dcqlRaw.value;
          }
        });

        modeBuilderBtn?.addEventListener("click", () => setMode("builder"));
        modeRawBtn?.addEventListener("click", () => setMode("raw"));

        form.addEventListener("submit", () => {
          if (mode === "builder") {
            dcqlHidden.value = JSON.stringify(buildDcqlObject());
          } else {
            dcqlHidden.value = dcqlRaw.value;
          }
          if (dcqlHidden && !dcqlHidden.value) {
            dcqlHidden.value = mode === "builder" ? JSON.stringify(buildDcqlObject()) : dcqlRaw.value;
          }
          if (!encryptionEnabled && clientMetadataField) {
            clientMetadataField.value = "";
          } else if (encryptionEnabled && clientMetadataField && !clientMetadataField.value.trim()) {
            clientMetadataField.value = savedClientMetadata || defaultClientMetadata || "";
          }
          if (authTypeSelect && clientIdInput && authTypeSelect.value === "verifier_attestation") {
            const val = clientIdInput.value || "";
            if (!val.startsWith("verifier_attestation:")) {
              clientIdInput.value = `verifier_attestation:${val}`;
            }
          } else if (authTypeSelect && clientIdInput && authTypeSelect.value === "x509_san_dns" && !clientIdInput.value && defaultX509SanId) {
            clientIdInput.value = defaultX509SanId;
          }
        });

        if (openBtn) {
          openBtn.addEventListener("click", () => form.requestSubmit());
        }

        parseInitialDefinition();
        renderBuilder();
        updatePreview();
        setEncryption(encryptionEnabled);
        setMode("builder");

        const sandboxButtons = document.getElementById("sandbox-buttons");
        if (sandboxButtons) {
          let sandboxActive = false;
          let sandboxData = null; // cached response from /sandbox-defaults

          const sandboxSdJwtBtn = document.getElementById("sandbox-sd-jwt");
          const sandboxMdocBtn = document.getElementById("sandbox-mdoc");
          const sandboxBothBtn = document.getElementById("sandbox-both");
          const sandboxMockBtn = document.getElementById("sandbox-mock");

          async function fetchSandboxData() {
            if (sandboxData) return sandboxData;
            const res = await fetch(sandboxButtons.dataset.sandboxUrl);
            const data = await res.json();
            if (data.available === false) { alert("Sandbox not configured."); return null; }
            sandboxData = data;
            return data;
          }

          function applyDcql(dcqlJson) {
            if (!dcqlJson) return;
            dcqlRaw.value = dcqlJson;
            rawInitialized = true;
            try {
              const parsed = JSON.parse(dcqlJson);
              const creds = Array.isArray(parsed.credentials) ? parsed.credentials : [];
              if (creds.length) {
                builderState = { credentials: creds.map((c, idx) => {
                  const claims = (Array.isArray(c.claims) ? c.claims : []).map(cl => {
                    const path = Array.isArray(cl.path) ? cl.path : [];
                    return { name: path.join("."), constValue: typeof cl.value !== "undefined" ? String(cl.value) : "", originalPath: path.length ? [...path] : null };
                  });
                  const meta = c.meta && typeof c.meta === "object" ? c.meta : null;
                  return { id: c.id || "credential-" + (idx + 1), format: c.format || "all", meta, claims: claims.length ? claims : defaultClaims(), claimSets: [] };
                }), credentialSets: Array.isArray(parsed.credential_sets) ? parsed.credential_sets : null };
                descriptorCounter = builderState.credentials.length + 1;
                renderBuilder();
              }
            } catch (e) { /* keep raw mode */ }
            updatePreview();
          }

          function applyFormDefaults(data) {
            if (authTypeSelect && data.authType) authTypeSelect.value = data.authType;
            if (requestObjectMode && data.requestObjectMode) requestObjectMode.value = data.requestObjectMode;
            const requestUriMethodEl = document.getElementById("requestUriMethod");
            if (requestUriMethodEl && data.requestUriMethod) requestUriMethodEl.value = data.requestUriMethod;
            const responseTypeEl = document.getElementById("responseType");
            if (responseTypeEl && data.responseType) responseTypeEl.value = data.responseType;
            const responseModeEl = document.getElementById("responseMode");
            if (responseModeEl && data.responseMode) responseModeEl.value = data.responseMode;
            const walletAuthEl = document.getElementById("walletAuthEndpoint");
            if (walletAuthEl && data.walletAuthEndpoint != null) walletAuthEl.value = data.walletAuthEndpoint;
            const walletAudienceEl = document.getElementById("walletAudience");
            if (walletAudienceEl && data.walletAudience != null) walletAudienceEl.value = data.walletAudience;
            if (clientIdInput && data.clientId != null) clientIdInput.value = data.clientId;
            if (data.walletClientCert) sandboxButtons._certChain = data.walletClientCert;
            const verifierInfoEl = document.getElementById("verifierInfo");
            if (verifierInfoEl && data.verifierInfo != null) verifierInfoEl.value = data.verifierInfo;
            const trustListEl = document.getElementById("trustList");
            if (trustListEl && data.trustListId) trustListEl.value = data.trustListId;
            if (data.clientMetadata && clientMetadataField) {
              clientMetadataField.value = data.clientMetadata;
              savedClientMetadata = data.clientMetadata;
              setEncryption(true);
            } else {
              if (clientMetadataField) clientMetadataField.value = "";
              savedClientMetadata = "";
              setEncryption(false);
            }
            refreshAuthSections();
          }

          function setSandboxMode(active, certChain) {
            if (useSandboxKeyInput) useSandboxKeyInput.value = active ? "true" : "false";
            if (x509Editable) x509Editable.style.display = active ? "none" : "block";
            if (x509Sandbox) x509Sandbox.style.display = active ? "block" : "none";
            if (active && sandboxCertDisplay) sandboxCertDisplay.value = certChain || "";
            if (active && clientCertInput) clientCertInput.value = "";
            if (!active && sandboxCertDisplay) sandboxCertDisplay.value = "";
            const verifierInfoEl = document.getElementById("verifierInfo");
            if (verifierInfoEl) verifierInfoEl.readOnly = active;
          }

          function showSandboxButtons(sandboxMode) {
            const isSandbox = !!sandboxMode;
            sandboxSdJwtBtn.style.display = isSandbox ? "none" : "";
            sandboxMdocBtn.style.display = isSandbox ? "none" : "";
            sandboxBothBtn.style.display = isSandbox ? "none" : "";
            sandboxMockBtn.style.display = isSandbox ? "" : "none";
          }

          async function activateSandbox(variant) {
            try {
              const data = await fetchSandboxData();
              if (!data) return;
              applyFormDefaults(data);
              const dcqlKey = variant === "sd-jwt" ? "dcqlSdJwt" : variant === "mdoc" ? "dcqlMdoc" : "dcqlBoth";
              applyDcql(data[dcqlKey] || data.dcqlQuery);
              sandboxActive = true;
              showSandboxButtons(true);
              setSandboxMode(true, sandboxButtons._certChain || "");
              refreshBindingInsights();
            } catch (e) {
              alert("Failed to load sandbox defaults: " + e.message);
            }
          }

          async function activateMock() {
            try {
              const res = await fetch(sandboxButtons.dataset.mockUrl);
              const data = await res.json();
              applyFormDefaults(data);
              applyDcql(data.dcqlQuery);
              sandboxActive = false;
              showSandboxButtons(false);
              setSandboxMode(false, "");
              refreshBindingInsights();
            } catch (e) {
              alert("Failed to load mock defaults: " + e.message);
            }
          }

          sandboxSdJwtBtn.addEventListener("click", () => activateSandbox("sd-jwt"));
          sandboxMdocBtn.addEventListener("click", () => activateSandbox("mdoc"));
          sandboxBothBtn.addEventListener("click", () => activateSandbox("both"));
          sandboxMockBtn.addEventListener("click", () => activateMock());
        }
      })();

      const verificationToggle = document.getElementById("verification-debug-toggle");
      const verificationPane = document.getElementById("verification-debug-pane");
      if (verificationToggle && verificationPane) {
        verificationToggle.addEventListener("click", () => {
          verificationPane.style.display = verificationPane.style.display === "none" ? "block" : "none";
        });
      }
    </script>
  </body>
</html>
